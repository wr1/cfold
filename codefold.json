{
  "instructions": [
    {
      "type": "assistant",
      "content": "This JSON file represents a project codebase in cfold format, with prompts for LLM.\nThe fields are 'instructions' (list of instruction objects), 'files'.\nEach instruction: {type: 'system'|'user'|'assistant', content: string, name: string (optional), synopsis: string (optional)}\nEach file in 'files': {path: string, content: Optional[string], delete: bool (default: false)}\nTo update the codebase, modify the 'files' array as per the following rules. Do not modify 'instructions' unless explicitly specified.\n- Folding: 'cfold fold <files> -o <output.json>' captures specified files into this .json.\n- Unfolding: 'cfold unfold <modified.json>' applies changes from this .json to the directory.\nRules:\n- To delete a file: Add an object to the 'files' array with 'path' and set 'delete': true (content can be null or omitted).\n- To add or modify a file: Add or update the object with 'path', full 'content', and 'delete': false (optional, default false).\n- To move/rename a file: Add a delete object for the old path ('delete': true) and a new object with the new 'path', full 'content', and 'delete': false.\n- Only include modified, new, or deleted files in the 'files' array; unchanged files are preserved from the original directory (if provided with -i).\n- Always provide full file content for additions and modifications; no partial updates.\n- Paths are relative to the current working directory (CWD) by default.\n- Supports .foldrc YAML file for custom dialects, patterns, and instructions, which can reference defaults via 'pre'.\n- Write output as a full dict {'files': [...] }, not the bare 'files' array.",
      "name": "common",
      "synopsis": "define cfold output format"
    },
    {
      "type": "system",
      "content": "You are an expert engineer, always aiming for superior usability, code quality, and performance. Follow best practices for the specific programming language or framework. Use appropriate libraries and tools for installation, documentation, vectorisation, and validation. Ensure code is modular, maintainable. Always follow PEP 8 for Python code style.",
      "name": "default",
      "synopsis": "role definition"
    },
    {
      "type": "user",
      "content": "Refactoring Guidelines:\n- Prefer organizing code into subdirectories based on functionality (e.g., 'src/<project>/utils/', 'src/<project>/core/', 'src/<project>/cli/').\n- Split functionality into small, focused files (e.g., one function or class per file where practical, typically 50-200 lines).\n- Aim for modularity: Each file should have a single responsibility, making it easier to modify or replace individually.\n- Don't include LLM instructions in the output.\n- Use high level 1 line docstrings\n- Add one character alternatives to command line options i.e. --file and -f\n- Never delete files that are outside of cwd (i.e. starting with ../ or / or otherwise outside of the cwd)\n- Make the CLI callable in pyproject.toml ",
      "name": "default",
      "synopsis": "define refactoring guidelines"
    },
    {
      "type": "user",
      "content": "add an admin.sh file in the root dir, where each file has a separate line for each file added, pipe output from ruff check and pytest to out.txt\nruff format \nruff check --fix > out.txt \ngit commit <filename> -m 'summary of edits for <filename>'\ngit commit <filename2> -m 'summary of edits for <filename2>'\n... for all files (but not the admin.sh file itself), if the files are new, add git add <filename> before git commit\nuv run pytest -v >> out.txt ",
      "name": "default",
      "synopsis": "instructions for authoring admin.sh"
    },
    {
      "type": "user",
      "content": "# Prefer uv for installation, mkdocs for documentation, use vectorisation using numpy, validation with pydantic. ",
      "name": "py",
      "synopsis": "python instructions"
    }
  ],
  "files": [
    {
      "path": "pyproject.toml",
      "content": "[project]\nname = \"cfold\"\nversion = \"0.2.3\"\ndescription = \"A command line tool to fold and unfold Python projects for LLM interaction\"\nauthors = [{ name = \"wr1\", email = \"8971152+wr1@users.noreply.github.com\" }]\nrequires-python = \"~=3.10\"\nreadme = \"README.md\"\nlicense = \"MIT\"\ndependencies = [\n    \"pyyaml>=6.0.2,<7\",\n    \"click>=8.1.7,<9\",\n    \"rich>=13.7.1\",\n    \"rich-click>=1.7.0\",  # Added for Rich-styled Click help\n    \"pyperclip>=1.8.2\",  # Added to handle clipboard operations\n    \"pydantic>=2.0.0,<3\",  # Added for data modeling  \n    \"treeparse @ git+https://github.com/wr1/treeparse.git@master\",  # Added for CLI parsing\n\n]\n\n[project.scripts]\ncfold = \"cfold.cli.main:main\"\n\n[dependency-groups]\ndev = [\n    \"ruff>=0.6.0\",\n    \"pytest>=7.1.3,<8\",\n    \"pytest-cov>5.0.0\",\n]\n\n[tool.hatch.build.targets.sdist]\ninclude = [\"src/cfold\"]\n\n[tool.hatch.build.targets.wheel]\ninclude = [\"src/cfold\"]\n\n[tool.hatch.build.targets.wheel.sources]\n\"src/cfold\" = \"cfold\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.metadata]\nallow-direct-references = true\n\n\n",
      "delete": false
    },
    {
      "path": "src/cfold/__init__.py",
      "content": "# Empty file as placeholder\n\n\n",
      "delete": false
    },
    {
      "path": "src/cfold/models.py",
      "content": "\"\"\"Pydantic models for cfold data structures.\"\"\"\n\nfrom typing import List, Optional\nfrom pydantic import BaseModel, field_validator, model_validator\n\n\nclass Instruction(BaseModel):\n    type: str  # 'system', 'user', or 'assistant'\n    content: str\n    name: Optional[str] = None\n    synopsis: Optional[str] = None\n\n\nclass FileEntry(BaseModel):\n    path: str\n    content: Optional[str] = None\n    delete: bool = False\n\n    @model_validator(mode=\"after\")\n    def check_content(self):\n        if not self.delete and self.content is None:\n            raise ValueError(\"Content must be provided if not deleting\")\n        return self\n\n\nclass Codebase(BaseModel):\n    instructions: List[Instruction] = []\n    files: List[FileEntry] = []\n\n    @field_validator(\"instructions\", mode=\"before\")\n    @classmethod\n    def convert_to_list(cls, v):\n        if isinstance(v, dict):\n            return [Instruction(**item) for item in v]\n        return v\n",
      "delete": false
    },
    {
      "path": "src/cfold/cli/fold.py",
      "content": "\"\"\"Handle folding command for cfold.\"\"\"\n\nimport os\nimport json\nfrom pathlib import Path\nimport pyperclip  # Added for clipboard functionality\nfrom cfold.utils.instructions import load_instructions, get_available_dialects\nimport yaml  # Added for loading .foldrc\nfrom cfold.utils.foldignore import should_include_file\nfrom rich.console import Console\nfrom rich.tree import Tree\nfrom cfold.utils.treeviz import get_folded_tree\nfrom cfold.models import Codebase, FileEntry, Instruction  # Added for Pydantic model\nimport sys\nfrom typing import List, Optional\n\n\ndef fold(\n    files: List[str],\n    output: str = \"codefold.json\",\n    prompt: str = None,\n    dialect: str = \"default\",\n    bare: bool = False,\n):\n    \"\"\"Fold files or directory into a single text file and visualize the structure.\"\"\"\n    bare = bool(bare)\n    console = Console()\n    cwd = Path.cwd()\n    # Check for local default dialect if 'default' is specified\n    if dialect == \"default\":\n        local_path = cwd / \".foldrc\"\n        if local_path.exists():\n            with local_path.open(\"r\", encoding=\"utf-8\") as f:\n                local_config = yaml.safe_load(f) or {}\n            if \"default_dialect\" in local_config:\n                dialect = local_config[\"default_dialect\"]\n\n    try:\n        instructions, patterns = load_instructions(dialect)\n        if bare:\n            instructions = []\n    except ValueError:\n        available = get_available_dialects()\n        console.print(\n            f\"Invalid dialect specified. Available dialects: {', '.join(available)}\",\n            style=\"red\",\n        )\n        sys.exit(1)\n    except Exception as e:\n        console.print(f\"Error loading instructions: {str(e)}\", style=\"red\")\n        sys.exit(1)\n\n    included_patterns = patterns.get(\"included\", [])  # Adjust if needed\n    excluded_patterns = patterns.get(\"excluded\", [])\n    included_dirs = patterns.get(\"included_dirs\", [])\n    exclude_files = patterns.get(\"exclude_files\", [])\n\n    if not files:\n        directory = cwd\n        files = []\n        for dirpath, _, filenames in os.walk(directory):\n            for filename in filenames:\n                filepath = Path(dirpath) / filename\n                rel_path = os.path.relpath(str(filepath), str(directory))\n                if (\n                    should_include_file(\n                        filepath,\n                        directory,\n                        included_patterns,\n                        excluded_patterns,\n                        included_dirs,\n                    )\n                    and rel_path not in exclude_files\n                ):\n                    files.append(filepath)\n    else:\n        files = [Path(f).absolute() for f in files if Path(f).is_file()]\n        files = [\n            f for f in files if os.path.relpath(str(f), str(cwd)) not in exclude_files\n        ]\n\n    if not files:\n        console.print(\"No valid files to fold.\")\n        return\n\n    data = Codebase(\n        instructions=instructions,\n        files=[\n            FileEntry(\n                path=os.path.relpath(str(filepath), str(cwd)),\n                content=open(filepath, \"r\", encoding=\"utf-8\").read(),\n            )\n            for filepath in files\n        ],\n    )\n\n    prompt_content = \"\"\n    if prompt and os.path.isfile(prompt):\n        with open(prompt, \"r\", encoding=\"utf-8\") as prompt_infile:\n            prompt_content = prompt_infile.read()\n    elif prompt:\n        console.print(\n            f\"Warning: Prompt file '{prompt}' does not exist. Skipping.\", style=\"yellow\"\n        )\n\n    if prompt_content:\n        data.instructions.append(\n            Instruction(type=\"user\", content=prompt_content, name=\"prompt\")\n        )\n\n    try:\n        with open(output, \"w\", encoding=\"utf-8\") as outfile:\n            json.dump(\n                data.model_dump(),\n                outfile,\n                indent=2,\n            )\n        # Copy content to clipboard after writing the file\n        pyperclip.copy(json.dumps(data.model_dump()))\n    except IOError as e:\n        console.print(f\"Error writing to {output}: {e}\", style=\"red\")\n        sys.exit(1)\n\n    file_tree = get_folded_tree(files, cwd)\n    if file_tree:\n        console.print(file_tree)\n\n    # Visualize instructions by type and name\n    instr_tree = Tree(\"Instructions Added\", guide_style=\"dim\")\n    for instr in data.instructions:\n        label = f\"[bold]{instr.type}[/bold]\"\n        if instr.name:\n            label += f\" ({instr.name})\"\n        if instr.synopsis:\n            label += f\" - {instr.synopsis}\"\n        instr_tree.add(label)\n    console.print(instr_tree)\n\n    console.print(\n        f\"Codebase folded into [cyan]{output}[/cyan] and content [green]copied to clipboard[/green].\"\n    )\n",
      "delete": false
    },
    {
      "path": "src/cfold/cli/main.py",
      "content": "\"\"\"Main CLI for cfold using treeparse.\"\"\"\n\n# import sys\n# from pathlib import Path\n\n# sys.path.append(str(Path(__file__).parent.parent.parent / \"treeparse\" / \"src\"))\n\n# from treeparse import cli, command, argument, option\n\nimport treeparse\nfrom typing import List, Optional\n\nfrom .fold import fold\nfrom .unfold import unfold\nfrom .rc import rc\nfrom .view import view\n\napp = treeparse.cli(\n    name=\"cfold\",\n    help=\"Fold code or docs tree into a single file with prompting for LLM interaction.\",\n    max_width=120,\n    show_types=True,\n    show_defaults=True,\n    line_connect=True,\n)\n\nfold_cmd = treeparse.command(\n    name=\"fold\",\n    help=\"Fold files or directory into a single text file and visualize the structure.\",\n    callback=fold,\n    arguments=[\n        treeparse.argument(\n            name=\"files\", arg_type=str, nargs=\"*\", default=[], sort_key=0\n        ),\n    ],\n    options=[\n        treeparse.option(\n            flags=[\"--output\", \"-o\"],\n            help=\"Output file\",\n            arg_type=str,\n            default=\"codefold.json\",\n            sort_key=0,\n        ),\n        treeparse.option(\n            flags=[\"--prompt\", \"-p\"],\n            help=\"Prompt file to append\",\n            arg_type=str,\n            default=None,\n            sort_key=1,\n        ),\n        treeparse.option(\n            flags=[\"--dialect\", \"-d\"],\n            help=\"Instruction dialect (available: default, py, pytest, doc, typst)\",\n            arg_type=str,\n            default=\"default\",\n            sort_key=2,\n        ),\n        treeparse.option(\n            flags=[\"--bare\", \"-b\"],\n            help=\"Bare mode without boilerplate instructions\",\n            default=False,\n            arg_type=bool,\n            sort_key=3,\n            # action=\"store_const\",\n            # const=\"True\",\n        ),\n    ],\n)\napp.commands.append(fold_cmd)\n\nunfold_cmd = treeparse.command(\n    name=\"unfold\",\n    help=\"Unfold a modified fold file into a directory.\",\n    callback=unfold,\n    arguments=[\n        treeparse.argument(name=\"foldfile\", arg_type=str, sort_key=0),\n    ],\n    options=[\n        treeparse.option(\n            flags=[\"--original-dir\", \"-i\"],\n            help=\"Original project directory\",\n            arg_type=str,\n            default=None,\n            sort_key=0,\n        ),\n        treeparse.option(\n            flags=[\"--output-dir\", \"-o\"],\n            help=\"Output directory\",\n            arg_type=str,\n            default=None,\n            sort_key=1,\n        ),\n    ],\n)\napp.commands.append(unfold_cmd)\n\nrc_cmd = treeparse.command(\n    name=\"rc\",\n    help=\"Create or update .foldrc with a 'local' profile and set it as the default dialect.\",\n    callback=rc,\n)\napp.commands.append(rc_cmd)\n\nview_cmd = treeparse.command(\n    name=\"view\",\n    help=\"View the prompts and files in a fold file.\",\n    callback=view,\n    arguments=[\n        treeparse.argument(name=\"foldfile\", arg_type=str, sort_key=0),\n    ],\n)\napp.commands.append(view_cmd)\n\n\ndef main():\n    app.run()\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "delete": false
    },
    {
      "path": "src/cfold/cli/__init__.py",
      "content": "# Empty file as placeholder\n\n\n",
      "delete": false
    },
    {
      "path": "src/cfold/cli/view.py",
      "content": "\"\"\"Handle viewing command for cfold.\"\"\"\n\nimport json\nfrom rich.console import Console\nfrom rich.tree import Tree\nfrom cfold.models import Codebase\n\n\ndef view(foldfile: str):\n    \"\"\"View the prompts and files in a fold file.\"\"\"\n    console = Console()\n\n    try:\n        with open(foldfile, \"r\", encoding=\"utf-8\") as infile:\n            raw_data = json.load(infile)\n            data = Codebase.model_validate(raw_data)\n    except Exception as e:\n        console.print(f\"Error loading {foldfile}: {e}\", style=\"red\")\n        return\n\n    # Visualize instructions\n    instr_tree = Tree(\"Instructions\", guide_style=\"dim\")\n    for instr in data.instructions:\n        label = f\"[bold]{instr.type}[/bold]\"\n        if instr.name:\n            label += f\" ({instr.name})\"\n        if instr.synopsis:\n            label += f\" - {instr.synopsis}\"\n        instr_tree.add(label)\n    console.print(instr_tree)\n\n    # Visualize files\n    files_tree = Tree(\"Files\", guide_style=\"dim\")\n    for file in data.files:\n        if file.delete:\n            files_tree.add(f\"[red]{file.path} (delete)[/red]\")\n        else:\n            files_tree.add(f\"[green]{file.path}[/green]\")\n    console.print(files_tree)\n",
      "delete": false
    },
    {
      "path": "src/cfold/cli/unfold.py",
      "content": "\"\"\"Handle unfolding command for cfold.\"\"\"\n\nimport os\nimport shutil\nimport json\nfrom rich.console import Console\nfrom rich.tree import Tree\nfrom pathlib import Path\nfrom cfold.utils.foldignore import should_include_file\nfrom cfold.models import Codebase  # Added for Pydantic model\n\n\ndef unfold(foldfile, original_dir=None, output_dir=None):\n    \"\"\"Unfold a modified fold file into a directory.\"\"\"\n    console = Console()\n    cwd = os.getcwd()\n    output_dir = os.path.abspath(output_dir or cwd)\n    output_path = Path(output_dir).resolve()\n    # Note: included_patterns etc. seem unused in unfold; if needed, adjust\n\n    with open(foldfile, \"r\", encoding=\"utf-8\") as infile:\n        raw_data = json.load(infile)\n        data = Codebase.model_validate(raw_data)\n\n    modified_files = {f.path: f for f in data.files}\n\n    if os.path.exists(output_dir) and os.listdir(output_dir):\n        console.print(f\"[dim]Merging into existing directory: {output_dir}[/dim]\")\n    else:\n        os.makedirs(output_dir, exist_ok=True)\n\n    added_files = []\n    deleted_files = []\n    modified_files_list = []\n\n    if original_dir and os.path.isdir(original_dir):\n        original_dir = os.path.abspath(original_dir)\n        for dirpath, _, filenames in os.walk(original_dir):\n            for filename in filenames:\n                filepath = os.path.join(dirpath, filename)\n                if should_include_file(\n                    filepath,\n                    original_dir,\n                    [],  # included_patterns empty or adjust\n                    [],  # excluded_patterns\n                    [],  # included_dirs\n                ):\n                    relpath = os.path.relpath(\n                        filepath, original_dir\n                    )  # Changed to relpath from original_dir\n                    dst = os.path.join(output_dir, relpath)\n                    if relpath in modified_files:\n                        entry = modified_files[relpath]\n                        if entry.delete:\n                            if os.path.exists(dst):\n                                os.remove(dst)\n                            deleted_files.append(relpath)\n                        else:\n                            os.makedirs(os.path.dirname(dst), exist_ok=True)\n                            with open(dst, \"w\", encoding=\"utf-8\") as outfile:\n                                outfile.write(entry.content)\n                            modified_files_list.append(relpath)\n                    else:\n                        os.makedirs(os.path.dirname(dst), exist_ok=True)\n                        if os.path.abspath(filepath) != os.path.abspath(dst):\n                            shutil.copy2(filepath, dst)\n                            added_files.append(relpath)\n\n        for path, entry in modified_files.items():\n            original_path = os.path.join(original_dir, path)\n            if os.path.exists(original_path):\n                continue  # Already handled\n            if entry.delete:\n                continue  # Skip deleting non-existing\n            full_path = os.path.join(output_dir, path)\n            resolved_path = Path(full_path).resolve()\n            if not resolved_path.is_relative_to(output_path):\n                console.print(\n                    f\"[yellow]Skipping addition outside output dir: {path}[/yellow]\"\n                )\n                continue\n            os.makedirs(os.path.dirname(full_path), exist_ok=True)\n            with open(full_path, \"w\", encoding=\"utf-8\") as outfile:\n                outfile.write(entry.content)\n            added_files.append(path)\n    else:\n        for path, entry in modified_files.items():\n            full_path = os.path.join(output_dir, path)\n            resolved_path = Path(full_path).resolve()\n            if not resolved_path.is_relative_to(output_path):\n                console.print(\n                    f\"[yellow]Skipping operation outside output dir: {path}[/yellow]\"\n                )\n                continue\n            if entry.delete:\n                if os.path.exists(full_path):\n                    os.remove(full_path)\n                    deleted_files.append(path)\n                continue\n            os.makedirs(os.path.dirname(full_path), exist_ok=True)\n            with open(full_path, \"w\", encoding=\"utf-8\") as outfile:\n                outfile.write(entry.content)\n            added_files.append(path)\n\n    # Output summary tree\n    tree = Tree(\n        f\"[bold dim]Operations in[/bold dim] [blue]{output_dir}[/blue]\",\n        guide_style=\"dim\",\n    )\n    if added_files:\n        added_node = tree.add(\"[green]Added files[/green]\")\n        for file in added_files:\n            added_node.add(\"[dim]\" + file + \"[/dim]\")\n    if deleted_files:\n        deleted_node = tree.add(\"[red]Deleted files[/red]\")\n        for file in deleted_files:\n            deleted_node.add(\"[dim]\" + file + \"[/dim]\")\n    if modified_files_list:\n        modified_node = tree.add(\"[yellow]Modified files[/yellow]\")\n        for file in modified_files_list:\n            modified_node.add(\"[dim]\" + file + \"[/dim]\")\n    console.print(tree)\n    console.print(f\"[bold dim]Codebase unfolded into {output_dir}[/bold dim]\")\n",
      "delete": false
    },
    {
      "path": "src/cfold/cli/rc.py",
      "content": "\"\"\"Handle rc command for cfold.\"\"\"\n\nfrom pathlib import Path\nimport yaml\nfrom rich.console import Console\n\n\ndef rc():\n    \"\"\"Create or update .foldrc with a 'local' profile and set it as the default dialect.\"\"\"\n    cwd = Path.cwd()\n    foldrc_path = cwd / \".foldrc\"\n    config = {}\n\n    if foldrc_path.exists():\n        with foldrc_path.open(\"r\", encoding=\"utf-8\") as f:\n            config = yaml.safe_load(f) or {}\n\n    # Add or update 'local' profile, inheriting from 'py'\n    if \"local\" not in config:\n        config[\"local\"] = {\n            \"pre\": [\"py\"],\n            \"instructions\": [\n                {\n                    \"type\": \"user\",\n                    \"synopsis\": \"local focus\",\n                    \"content\": \"Focus on brief and modular code.\",\n                }\n            ],\n            \"included_suffix\": [\".py\", \".toml\"],\n        }\n\n    # Set default_dialect to 'local'\n    config[\"default_dialect\"] = \"local\"\n\n    with foldrc_path.open(\"w\", encoding=\"utf-8\") as f:\n        yaml.safe_dump(config, f, default_flow_style=False)\n\n    console = Console()\n    console.print(\n        \"[green].foldrc created/updated with 'local' as default dialect.[/green]\"\n    )\n",
      "delete": false
    },
    {
      "path": "src/cfold/utils/instructions.py",
      "content": "\"\"\"Load instructions and patterns for specified dialect.\"\"\"\n\nfrom importlib import resources\nfrom pathlib import Path\nimport yaml\nfrom typing import List, Dict, Optional\nfrom cfold.models import Instruction\n\n\ndef collect_instructions(\n    config: Dict, dialect: str, processed: set = None, path: set = None\n) -> List[Instruction]:\n    \"\"\"Recursively collect instructions for the dialect, handling 'pre' dependencies without duplicates.\"\"\"\n    if processed is None:\n        processed = set()\n    if path is None:\n        path = set()\n\n    if dialect in processed:\n        return []\n    if dialect in path:\n        raise ValueError(f\"Cycle detected in 'pre' for dialect '{dialect}'\")\n\n    path.add(dialect)\n    instr = config.get(dialect)\n    if instr is None:\n        path.remove(dialect)\n        return []\n    if not isinstance(instr, dict):\n        raise ValueError(\n            f\"Dialect '{dialect}' config must be a dictionary, got {type(instr).__name__}\"\n        )\n\n    instructions = []\n    for pre_d in instr.get(\"pre\", []):\n        instructions.extend(collect_instructions(config, pre_d, processed, path))\n\n    path.remove(dialect)\n    processed.add(dialect)\n\n    for i in instr.get(\"instructions\", []):\n        instructions.append(Instruction(**i, name=dialect))\n\n    return instructions\n\n\ndef collect_patterns(\n    config: Dict, dialect: str, processed: set = None, path: set = None\n) -> Dict[str, List[str]]:\n    \"\"\"Recursively collect patterns for the dialect, handling 'pre' dependencies.\"\"\"\n    if processed is None:\n        processed = set()\n    if path is None:\n        path = set()\n\n    if dialect in processed:\n        return {}\n    if dialect in path:\n        raise ValueError(f\"Cycle detected in 'pre' for patterns in '{dialect}'\")\n\n    path.add(dialect)\n    instr = config.get(dialect, {})\n\n    patterns = {\n        \"included_suffix\": [],\n        \"excluded\": [],\n        \"included_dirs\": [],\n        \"exclude\": [],\n    }\n\n    for pre_d in instr.get(\"pre\", []):\n        pre_patterns = collect_patterns(config, pre_d, processed, path)\n        for key in patterns:\n            patterns[key].extend(pre_patterns.get(key, []))\n\n    for key in patterns:\n        patterns[key].extend(instr.get(key, []))\n\n    path.remove(dialect)\n    processed.add(dialect)\n    return patterns\n\n\ndef load_instructions(\n    dialect: str = \"default\", directory: Optional[Path] = None\n) -> tuple[List[Instruction], Dict]:\n    \"\"\"Load the boilerplate instructions and patterns for the specified dialect from prompts.yaml as a list of Instruction.\"\"\"\n    if directory is None:\n        directory = Path.cwd()\n    local_config = {}\n    local_path = directory / \".foldrc\"\n    if local_path.exists():\n        with local_path.open(\"r\", encoding=\"utf-8\") as f:\n            local_config = yaml.safe_load(f) or {}\n\n    try:\n        with (\n            resources.files(\"cfold\")\n            .joinpath(\"resources/prompts.yaml\")\n            .open(\"r\", encoding=\"utf-8\")\n        ) as f:\n            default_config = yaml.safe_load(f)  # Use safe_load for security\n    except Exception as e:\n        raise RuntimeError(f\"Failed to load default instructions: {e}\")\n\n    combined_config = {**default_config, **local_config}\n\n    if dialect not in combined_config:\n        raise ValueError(f\"Dialect '{dialect}' not found in combined configurations\")\n    instructions_list = collect_instructions(combined_config, dialect)\n    all_patterns = collect_patterns(combined_config, dialect)\n\n    # Override with defaults for specific dialects\n    if dialect in (\"py\", \"pytest\"):\n        all_patterns[\"included_suffix\"] = [\".py\", \".toml\"]\n    elif dialect == \"doc\":\n        all_patterns[\"included_suffix\"] = [\".md\", \".rst\"]\n    elif dialect == \"typst\":\n        all_patterns[\"included_suffix\"] = [\".typ\"]\n\n    patterns = {\n        \"included\": [\n            f\"*{pat}\" for pat in all_patterns.get(\"included_suffix\", [])\n        ],  # Convert suffixes to fnmatch patterns\n        \"excluded\": all_patterns.get(\"excluded\", []),\n        \"included_dirs\": all_patterns.get(\"included_dirs\", []),\n        \"exclude_files\": all_patterns.get(\"exclude\", []),\n    }\n    return instructions_list, patterns\n\n\ndef get_available_dialects(directory: Optional[Path] = None) -> List[str]:\n    \"\"\"Get the list of available dialects from prompts.yaml and .foldrc.\"\"\"\n    if directory is None:\n        directory = Path.cwd()\n    local_config = {}\n    local_path = directory / \".foldrc\"\n    if local_path.exists():\n        with local_path.open(\"r\", encoding=\"utf-8\") as f:\n            local_config = yaml.safe_load(f) or {}\n\n    try:\n        with (\n            resources.files(\"cfold\")\n            .joinpath(\"resources/prompts.yaml\")\n            .open(\"r\", encoding=\"utf-8\")\n        ) as f:\n            default_config = yaml.safe_load(f)\n    except Exception as e:\n        raise RuntimeError(f\"Failed to load dialects: {e}\")\n\n    combined_config = {**default_config, **local_config}\n    return [k for k in combined_config.keys() if k != \"common\"]\n",
      "delete": false
    },
    {
      "path": "src/cfold/utils/treeviz.py",
      "content": "\"\"\"Utilities for visualizing file trees using Rich Tree.\"\"\"\n\nimport os\nfrom rich.tree import Tree  # Import Rich Tree class\n\n\ndef get_folded_tree(files, cwd):\n    \"\"\"Generate a Rich Tree object for the folded files with dim styling.\"\"\"\n    main_tree = Tree(\"Folded files tree\", guide_style=\"dim\")  # Create the main Tree\n    for file_path in sorted(set(os.path.relpath(f, cwd) for f in files)):\n        parts = file_path.split(os.sep)\n        current_node = main_tree\n        for part in parts[:-1]:  # Traverse directories\n            subnodes = [\n                node for node in current_node.children if node.label == part + os.sep\n            ]\n            if subnodes:\n                current_node = subnodes[0]\n            else:\n                new_node = current_node.add(\n                    f\"{part + os.sep}\"\n                )  # Add directory node with dim\n                current_node = new_node\n        if parts[-1].endswith(\".py\"):\n            current_node.add(f\"[green]{parts[-1]}[/green]\")\n        elif parts[-1].endswith(\".tex\") or parts[-1].endswith(\".md\"):\n            current_node.add(f\"[cyan]{parts[-1]}[/cyan]\")\n        elif parts[-1].endswith(\".yml\") or parts[-1].endswith(\".toml\"):\n            current_node.add(f\"[yellow]{parts[-1]}[/yellow]\")\n        else:\n            current_node.add(f\"{parts[-1]}\")  # Add the file node with dim\n    return main_tree  # Return the Rich Tree object\n",
      "delete": false
    },
    {
      "path": "src/cfold/utils/__init__.py",
      "content": "# Empty file as placeholder\n\n\n",
      "delete": false
    },
    {
      "path": "src/cfold/utils/foldignore.py",
      "content": "from pathlib import Path\nimport fnmatch\nimport os\n\n\ndef should_include_file(\n    filepath,\n    root_dir=None,\n    included_patterns=None,\n    excluded_patterns=None,\n    included_dirs=None,\n):\n    \"\"\"Check if a file should be included based on patterns.\"\"\"\n    EXCLUDED_DIRS = {\n        \".pytest_cache\",\n        \"__pycache__\",\n        \"build\",\n        \"dist\",\n        \".egg-info\",\n        \"venv\",\n        \".venv\",\n        \".ruff_cache\",\n        \".git\",\n        \"node_modules\",  # Added to ignore common directories\n    }\n    EXCLUDED_FILES = {\".pyc\", \".egg-info\"}\n\n    path = Path(filepath)\n    if root_dir:\n        relpath = os.path.relpath(filepath, root_dir)\n    else:\n        relpath = str(path)\n\n    relpath_norm = relpath.replace(os.sep, \"/\")\n    if included_dirs:\n        is_in_included_dir = any(\n            relpath_norm.startswith(d.replace(os.sep, \"/\") + \"/\") for d in included_dirs\n        )\n        is_root_file = \".\" in included_dirs and \"/\" not in relpath_norm\n        if not (is_in_included_dir or is_root_file):\n            return False\n\n    EXCLUDED_PATTERNS = [\n        \"*.egg-info/*\",\n        \".*rc\",\n        \"*.txt\",\n        \"*.json\",\n        \"build/*\",\n        \"dist/*\",\n        \".venv/*\",\n        # \"example*\",\n        \"htmlcov/*\",\n        \"*png\",\n        \"*vtu\",\n        \"*xdmf\",\n        \"*data/*\",\n        \"*log\",\n        \".*\",\n        \"*sh\",\n    ]\n\n    if excluded_patterns is None:\n        excluded_patterns = []\n    for i in EXCLUDED_PATTERNS:\n        if i not in excluded_patterns:\n            excluded_patterns.append(i)\n\n    if any(part in EXCLUDED_DIRS for part in path.parts):\n        return False\n    if path.suffix in EXCLUDED_FILES:\n        return False\n\n    if included_patterns and not any(\n        fnmatch.fnmatch(relpath, pattern) for pattern in included_patterns\n    ):\n        return False\n    if excluded_patterns and any(\n        fnmatch.fnmatch(relpath, pattern) for pattern in excluded_patterns\n    ):\n        return False\n    return True\n",
      "delete": false
    },
    {
      "path": "tests/test_models.py",
      "content": "from cfold.models import Codebase, FileEntry, Instruction\nfrom pydantic import ValidationError\nimport pytest\n\n\ndef test_fileentry_validation():\n    \"\"\"Test FileEntry validation.\"\"\"\n    # Valid with content\n    entry = FileEntry(path=\"file.py\", content=\"content\")\n    assert entry.delete is False\n    assert entry.content == \"content\"\n\n    # Valid delete without content\n    entry = FileEntry(path=\"file.py\", delete=True)\n    assert entry.delete is True\n    assert entry.content is None\n\n    # Invalid: no content and not delete\n    with pytest.raises(ValidationError):\n        FileEntry(path=\"file.py\")\n\n    # Invalid: delete with content (but allowed, as per model)\n    entry = FileEntry(path=\"file.py\", delete=True, content=\"ignored\")\n    assert entry.content == \"ignored\"\n\n\ndef test_instruction():\n    \"\"\"Test Instruction model.\"\"\"\n    instr = Instruction(type=\"system\", content=\"content\", name=\"test\", synopsis=\"syn\")\n    assert instr.type == \"system\"\n    assert instr.synopsis == \"syn\"  # Internal field\n\n\ndef test_codebase():\n    \"\"\"Test Codebase model.\"\"\"\n    codebase = Codebase(\n        instructions=[Instruction(type=\"user\", content=\"prompt\")],\n        files=[FileEntry(path=\"file.py\", content=\"code\")],\n    )\n    dumped = codebase.model_dump(exclude={\"instructions\": {\"__all__\": {\"synopsis\"}}})\n    assert \"synopsis\" not in dumped[\"instructions\"][0]\n\n    # Test validator for instructions as dict (though not typically used)\n    codebase = Codebase.model_validate({\"instructions\": [], \"files\": []})\n    assert isinstance(codebase.instructions, list)\n",
      "delete": false
    },
    {
      "path": "tests/test_cfold.py",
      "content": "import pytest\nimport json\nimport sys\nimport yaml\nfrom pathlib import Path\n\nsys.path.append(str(Path(__file__).parent.parent / \"src\"))\nsys.path.append(str(Path(__file__).parent.parent.parent / \"treeparse\" / \"src\"))\n\nfrom cfold.cli.main import main  # Updated import\n\n\n@pytest.fixture\ndef temp_project(tmp_path):\n    \"\"\"Create a temporary project directory with sample files.\"\"\"\n    proj_dir = tmp_path\n    src_dir = proj_dir / \"src\" / \"project\"\n    src_dir.mkdir(parents=True)\n    (src_dir / \"main.py\").write_text('print(\"Hello\")\\n')\n    (src_dir / \"utils.py\").write_text(\"def util():\\n    pass\\n\")\n    (src_dir / \"importer.py\").write_text(\"from project.main import *\\n\")\n    (proj_dir / \"docs\").mkdir(exist_ok=True)\n    (proj_dir / \"docs\" / \"index.md\").write_text(\"# Docs\\n\")\n    return proj_dir\n\n\ndef test_fold(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test fold command creates correct output.\"\"\"\n    files = [\n        str(temp_project / \"src\" / \"project\" / \"main.py\"),\n        str(temp_project / \"docs\" / \"index.md\"),\n    ]\n    output_file = tmp_path / \"folded.json\"\n    monkeypatch.chdir(tmp_path)\n    monkeypatch.setattr(\n        sys,\n        \"argv\",\n        [\"cfold\", \"fold\"] + files + [\"-o\", str(output_file), \"-d\", \"default\"],\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase folded into\" in captured.out\n    assert output_file.exists()\n    with open(output_file, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n    assert \"instructions\" in data\n    assert len(data[\"files\"]) == 2\n    assert data[\"files\"][0][\"path\"] == \"src/project/main.py\"\n    assert data[\"files\"][0][\"content\"] == 'print(\"Hello\")\\n'\n    assert data[\"files\"][1][\"path\"] == \"docs/index.md\"\n    assert data[\"files\"][1][\"content\"] == \"# Docs\\n\"\n\n\ndef test_fold_directory_default(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test folding directory when no files specified.\"\"\"\n    output_file = tmp_path / \"folded.json\"\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(\n        sys, \"argv\", [\"cfold\", \"fold\", \"-o\", str(output_file), \"-d\", \"default\"]\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase folded into\" in captured.out\n    assert output_file.exists()\n    with open(output_file, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n    assert any(f[\"path\"] == \"src/project/main.py\" for f in data[\"files\"])\n    assert any(f[\"path\"] == \"docs/index.md\" for f in data[\"files\"])\n    assert any(f[\"path\"] == \"src/project/utils.py\" for f in data[\"files\"])\n\n\ndef test_fold_dialect_codeonly(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test codeonly dialect excludes non-code files.\"\"\"\n    output_file = tmp_path / \"folded.json\"\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(\n        sys, \"argv\", [\"cfold\", \"fold\", \"-o\", str(output_file), \"-d\", \"py\"]\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase folded into\" in captured.out\n    assert output_file.exists()\n    with open(output_file, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n    assert any(f[\"path\"] == \"src/project/main.py\" for f in data[\"files\"])\n    assert any(f[\"path\"] == \"src/project/utils.py\" for f in data[\"files\"])\n    assert any(f[\"path\"] == \"src/project/importer.py\" for f in data[\"files\"])\n    assert not any(f[\"path\"] == \"docs/index.md\" for f in data[\"files\"])\n\n\ndef test_fold_dialect_doconly(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test doconly dialect includes only doc files.\"\"\"\n    output_file = tmp_path / \"folded.json\"\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(\n        sys, \"argv\", [\"cfold\", \"fold\", \"-o\", str(output_file), \"-d\", \"doc\"]\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase folded into\" in captured.out\n    assert output_file.exists()\n    with open(output_file, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n    assert any(f[\"path\"] == \"docs/index.md\" for f in data[\"files\"])\n    assert not any(f[\"path\"] == \"src/project/utils.py\" for f in data[\"files\"])\n    assert not any(f[\"path\"] == \"src/project/importer.py\" for f in data[\"files\"])\n\n\ndef test_unfold_new_files(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test unfolding new files.\"\"\"\n    fold_file = tmp_path / \"folded.json\"\n    data = {\n        \"instructions\": [],\n        \"files\": [\n            {\"path\": \"src/project/new.py\", \"content\": \"print('New file')\\n\"},\n            {\"path\": \"docs/new.md\", \"content\": \"# New Doc\\n\"},\n        ],\n    }\n    with open(fold_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f)\n    output_dir = tmp_path / \"unfolded\"\n    output_dir.mkdir()\n    monkeypatch.chdir(tmp_path)\n    monkeypatch.setattr(\n        sys, \"argv\", [\"cfold\", \"unfold\", str(fold_file), \"-o\", str(output_dir)]\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase unfolded into\" in captured.out\n    assert (output_dir / \"src\" / \"project\" / \"new.py\").exists()\n    assert (\n        output_dir / \"src\" / \"project\" / \"new.py\"\n    ).read_text() == \"print('New file')\\n\"\n    assert (output_dir / \"docs\" / \"new.md\").exists()\n    assert (output_dir / \"docs\" / \"new.md\").read_text() == \"# New Doc\\n\"\n\n\ndef test_unfold_modify_and_delete(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test unfolding with modifications and deletions.\"\"\"\n    fold_file = tmp_path / \"folded.json\"\n    data = {\n        \"instructions\": [],\n        \"files\": [\n            {\"path\": \"src/project/main.py\", \"content\": \"print('Modified')\\n\"},\n            {\"path\": \"src/project/utils.py\", \"delete\": True, \"content\": None},\n        ],\n    }\n    with open(fold_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f)\n    output_dir = tmp_path / \"unfolded\"\n    output_dir.mkdir()\n    monkeypatch.chdir(tmp_path)\n    monkeypatch.setattr(\n        sys,\n        \"argv\",\n        [\n            \"cfold\",\n            \"unfold\",\n            str(fold_file),\n            \"-i\",\n            str(temp_project),\n            \"-o\",\n            str(output_dir),\n        ],\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase unfolded into\" in captured.out\n    assert (output_dir / \"src\" / \"project\" / \"main.py\").exists()\n    assert (\n        output_dir / \"src\" / \"project\" / \"main.py\"\n    ).read_text() == \"print('Modified')\\n\"\n    assert not (output_dir / \"src\" / \"project\" / \"utils.py\").exists()\n    assert (output_dir / \"docs\" / \"index.md\").exists()\n\n\ndef test_unfold_relocate_and_update_references(\n    temp_project, tmp_path, monkeypatch, capsys\n):\n    \"\"\"Test unfolding with file relocation.\"\"\"\n    fold_file = tmp_path / \"folded.json\"\n    data = {\n        \"instructions\": [],\n        \"files\": [\n            {\"path\": \"src/project/main.py\", \"delete\": True, \"content\": None},\n            {\"path\": \"src/project/core/main.py\", \"content\": 'print(\"Hello\")\\n'},\n            {\n                \"path\": \"src/project/importer.py\",\n                \"content\": \"from project.core.main import *\\n\",\n            },\n        ],\n    }\n    with open(fold_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f)\n    output_dir = tmp_path / \"unfolded\"\n    output_dir.mkdir()\n    monkeypatch.chdir(tmp_path)\n    monkeypatch.setattr(\n        sys,\n        \"argv\",\n        [\n            \"cfold\",\n            \"unfold\",\n            str(fold_file),\n            \"-i\",\n            str(temp_project),\n            \"-o\",\n            str(output_dir),\n        ],\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase unfolded into\" in captured.out\n    assert (output_dir / \"src\" / \"project\" / \"core\" / \"main.py\").exists()\n    assert (\n        output_dir / \"src\" / \"project\" / \"core\" / \"main.py\"\n    ).read_text() == 'print(\"Hello\")\\n'\n    assert not (output_dir / \"src\" / \"project\" / \"main.py\").exists()\n    assert (\n        output_dir / \"src\" / \"project\" / \"importer.py\"\n    ).read_text() == \"from project.core.main import *\\n\"\n\n\ndef test_unfold_complex_full_content(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test unfolding complex full-content file.\"\"\"\n    fold_file = tmp_path / \"complex_full.json\"\n    data = {\n        \"instructions\": [],\n        \"files\": [\n            {\n                \"path\": \"src/project/main.py\",\n                \"content\": 'print(\"Modified Hello\")\\nprint(\"Extra line\")\\n',\n            },\n            {\"path\": \"src/project/utils.py\", \"delete\": True, \"content\": None},\n            {\n                \"path\": \"src/project/core/utils.py\",\n                \"content\": \"def new_util():\\n    return 42\\n\",\n            },\n            {\n                \"path\": \"src/project/importer.py\",\n                \"content\": \"from project.main import *\\nprint('Imported')\\n\",\n            },\n            {\"path\": \"docs/index.md\", \"delete\": True, \"content\": None},\n            {\"path\": \"src/project/new_file.py\", \"content\": \"print('Brand new file')\\n\"},\n        ],\n    }\n    with open(fold_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f)\n    output_dir = tmp_path / \"unfolded\"\n    output_dir.mkdir()\n    monkeypatch.chdir(tmp_path)\n    monkeypatch.setattr(\n        sys,\n        \"argv\",\n        [\n            \"cfold\",\n            \"unfold\",\n            str(fold_file),\n            \"-i\",\n            str(temp_project),\n            \"-o\",\n            str(output_dir),\n        ],\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase unfolded into\" in captured.out\n    assert (\n        output_dir / \"src\" / \"project\" / \"main.py\"\n    ).read_text() == 'print(\"Modified Hello\")\\nprint(\"Extra line\")\\n'\n    assert (\n        output_dir / \"src\" / \"project\" / \"core\" / \"utils.py\"\n    ).read_text() == \"def new_util():\\n    return 42\\n\"\n    assert not (output_dir / \"src\" / \"project\" / \"utils.py\").exists()\n    assert (\n        output_dir / \"src\" / \"project\" / \"importer.py\"\n    ).read_text() == \"from project.main import *\\nprint('Imported')\\n\"\n    assert not (output_dir / \"docs\" / \"index.md\").exists()\n    assert (\n        output_dir / \"src\" / \"project\" / \"new_file.py\"\n    ).read_text() == \"print('Brand new file')\\n\"\n\n\ndef test_unfold_md_commands_not_interpreted(\n    temp_project, tmp_path, monkeypatch, capsys\n):\n    \"\"\"Test MOVE/DELETE in .md files not interpreted.\"\"\"\n    fold_file = tmp_path / \"folded.json\"\n    data = {\n        \"instructions\": [],\n        \"files\": [\n            {\n                \"path\": \"docs/example.md\",\n                \"content\": \"# Example\\n\\nHere's how to delete a file:\\n# DELETE\\n# MOVE: src/project/main.py -> src/project/core/main.py\\n\",\n            }\n        ],\n    }\n    with open(fold_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f)\n    output_dir = tmp_path / \"unfolded\"\n    output_dir.mkdir()\n    monkeypatch.chdir(tmp_path)\n    monkeypatch.setattr(\n        sys,\n        \"argv\",\n        [\n            \"cfold\",\n            \"unfold\",\n            str(fold_file),\n            \"-i\",\n            str(temp_project),\n            \"-o\",\n            str(output_dir),\n        ],\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase unfolded into\" in captured.out\n    example_content = (output_dir / \"docs\" / \"example.md\").read_text()\n    assert \"# Example\" in example_content\n    assert \"# DELETE\" in example_content\n    assert (\n        output_dir / \"src\" / \"project\" / \"utils.py\"\n    ).exists()  # Assuming it's copied\n\n\ndef test_fold_invalid_dialect(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test fold with invalid dialect raises error.\"\"\"\n    output_file = tmp_path / \"folded.json\"\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(\n        sys, \"argv\", [\"cfold\", \"fold\", \"-o\", str(output_file), \"-d\", \"invalid\"]\n    )\n    with pytest.raises(SystemExit) as exc:\n        main()\n    assert exc.value.code == 1\n    captured = capsys.readouterr()\n    assert \"Invalid dialect specified\" in captured.out\n\n\ndef test_fold_no_files(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test fold with no valid files.\"\"\"\n    output_file = tmp_path / \"folded.json\"\n    monkeypatch.chdir(\n        temp_project / \"docs\"\n    )  # Change to a dir with no includable files for py dialect\n    monkeypatch.setattr(\n        sys, \"argv\", [\"cfold\", \"fold\", \"-o\", str(output_file), \"-d\", \"py\"]\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"No valid files to fold.\" in captured.out\n    assert not output_file.exists()\n\n\ndef test_fold_with_prompt(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test fold with prompt file.\"\"\"\n    output_file = tmp_path / \"folded.json\"\n    prompt_file = tmp_path / \"prompt.txt\"\n    prompt_file.write_text(\"Custom prompt content\")\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(\n        sys,\n        \"argv\",\n        [\n            \"cfold\",\n            \"fold\",\n            \"-o\",\n            str(output_file),\n            \"-p\",\n            str(prompt_file),\n            \"-d\",\n            \"default\",\n        ],\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase folded into\" in captured.out\n    with open(output_file, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n    assert any(\n        i[\"content\"] == \"Custom prompt content\" and i[\"type\"] == \"user\"\n        for i in data[\"instructions\"]\n    )\n\n\ndef test_fold_with_invalid_prompt(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test fold with non-existing prompt file.\"\"\"\n    output_file = tmp_path / \"folded.json\"\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(\n        sys,\n        \"argv\",\n        [\n            \"cfold\",\n            \"fold\",\n            \"-o\",\n            str(output_file),\n            \"-p\",\n            \"nonexistent.txt\",\n            \"-d\",\n            \"default\",\n        ],\n    )\n    main()\n    captured = capsys.readouterr()\n    assert (\n        \"Warning: Prompt file 'nonexistent.txt' does not exist. Skipping.\"\n        in captured.out\n    )\n    assert \"Codebase folded into\" in captured.out\n\n\ndef test_unfold_without_original_dir(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test unfold without original directory.\"\"\"\n    fold_file = tmp_path / \"folded.json\"\n    data = {\n        \"instructions\": [],\n        \"files\": [\n            {\"path\": \"new_file.py\", \"content\": \"print('New')\\n\"},\n            {\"path\": \"to_delete.py\", \"delete\": True},\n        ],\n    }\n    with open(fold_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f)\n    output_dir = tmp_path / \"unfolded\"\n    output_dir.mkdir()\n    monkeypatch.chdir(tmp_path)\n    monkeypatch.setattr(\n        sys, \"argv\", [\"cfold\", \"unfold\", str(fold_file), \"-o\", str(output_dir)]\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase unfolded into\" in captured.out\n    assert (output_dir / \"new_file.py\").exists()\n    assert not (output_dir / \"to_delete.py\").exists()\n\n\ndef test_unfold_merge_existing_dir(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test unfold merging into existing directory.\"\"\"\n    fold_file = tmp_path / \"folded.json\"\n    data = {\n        \"instructions\": [],\n        \"files\": [\n            {\"path\": \"existing.py\", \"content\": \"print('Modified')\\n\"},\n        ],\n    }\n    with open(fold_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f)\n    output_dir = tmp_path / \"unfolded\"\n    output_dir.mkdir()\n    (output_dir / \"existing.py\").write_text(\"original\")\n    (output_dir / \"unchanged.py\").write_text(\"unchanged\")\n    monkeypatch.chdir(tmp_path)\n    monkeypatch.setattr(\n        sys, \"argv\", [\"cfold\", \"unfold\", str(fold_file), \"-o\", str(output_dir)]\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase unfolded into\" in captured.out\n    assert (output_dir / \"existing.py\").read_text() == \"print('Modified')\\n\"\n    assert (output_dir / \"unchanged.py\").read_text() == \"unchanged\"\n\n\ndef test_unfold_delete_outside_cwd(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test unfold does not delete files outside CWD.\"\"\"\n    fold_file = tmp_path / \"folded.json\"\n    data = {\n        \"instructions\": [],\n        \"files\": [\n            {\"path\": \"../outside.py\", \"delete\": True},\n        ],\n    }\n    with open(fold_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f)\n    output_dir = tmp_path / \"unfolded\"\n    output_dir.mkdir()\n    outside_file = tmp_path / \"outside.py\"\n    outside_file.write_text(\"should not delete\")\n    monkeypatch.chdir(output_dir)\n    monkeypatch.setattr(sys, \"argv\", [\"cfold\", \"unfold\", str(fold_file), \"-o\", \".\"])\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase unfolded into\" in captured.out\n    assert outside_file.exists()  # Should not be deleted\n\n\ndef test_rc_command(temp_project, monkeypatch, capsys):\n    \"\"\"Test rc command creates .foldrc with local as default.\"\"\"\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(sys, \"argv\", [\"cfold\", \"rc\"])\n    main()\n    captured = capsys.readouterr()\n    assert \".foldrc created/updated\" in captured.out\n    foldrc_path = temp_project / \".foldrc\"\n    assert foldrc_path.exists()\n    with open(foldrc_path, \"r\", encoding=\"utf-8\") as f:\n        config = yaml.safe_load(f)\n    assert \"default_dialect\" in config and config[\"default_dialect\"] == \"local\"\n    assert \"local\" in config\n    assert config[\"local\"][\"pre\"] == [\"py\"]\n    assert config[\"local\"][\"instructions\"] == [\n        {\n            \"type\": \"user\",\n            \"synopsis\": \"local focus\",\n            \"content\": \"Focus on brief and modular code.\",\n        }\n    ]\n    assert config[\"local\"][\"included_suffix\"] == [\".py\", \".toml\"]\n\n\ndef test_fold_uses_local_default(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test fold uses local default dialect from .foldrc.\"\"\"\n    foldrc_path = temp_project / \".foldrc\"\n    config = {\"default_dialect\": \"py\"}\n    with open(foldrc_path, \"w\", encoding=\"utf-8\") as f:\n        yaml.safe_dump(config, f)\n    output_file = tmp_path / \"folded.json\"\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(sys, \"argv\", [\"cfold\", \"fold\", \"-o\", str(output_file)])\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase folded into\" in captured.out\n    with open(output_file, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n    # Check if it used 'py' dialect (excludes .md)\n    assert any(f[\"path\"] == \"src/project/main.py\" for f in data[\"files\"])\n    assert not any(f[\"path\"] == \"docs/index.md\" for f in data[\"files\"])\n\n\ndef test_fold_bare(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test fold in bare mode has no instructions.\"\"\"\n    output_file = tmp_path / \"folded.json\"\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(\n        sys, \"argv\", [\"cfold\", \"fold\", \"-o\", str(output_file), \"-b\", \"True\", \"-d\", \"default\"]\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase folded into\" in captured.out\n    with open(output_file, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n    assert data[\"instructions\"] == []\n    assert any(f[\"path\"] == \"src/project/main.py\" for f in data[\"files\"])\n    assert any(f[\"path\"] == \"docs/index.md\" for f in data[\"files\"])\n\n\ndef test_fold_bare_with_prompt(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test fold in bare mode with prompt includes only the prompt.\"\"\"\n    output_file = tmp_path / \"folded.json\"\n    prompt_file = tmp_path / \"prompt.txt\"\n    prompt_file.write_text(\"Custom prompt\")\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(\n        sys,\n        \"argv\",\n        [\n            \"cfold\",\n            \"fold\",\n            \"-o\",\n            str(output_file),\n            \"-b\",\n            \"True\",\n            \"-p\",\n            str(prompt_file),\n            \"-d\",\n            \"default\",\n        ],\n    )\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase folded into\" in captured.out\n    with open(output_file, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n    assert len(data[\"instructions\"]) == 1\n    assert data[\"instructions\"][0][\"content\"] == \"Custom prompt\"\n    assert data[\"instructions\"][0][\"type\"] == \"user\"\n    assert any(f[\"path\"] == \"src/project/main.py\" for f in data[\"files\"])\n    assert any(f[\"path\"] == \"docs/index.md\" for f in data[\"files\"])\n\n\ndef test_fold_with_exclude(temp_project, tmp_path, monkeypatch, capsys):\n    \"\"\"Test fold excludes files specified in dialect's exclude list.\"\"\"\n    foldrc_path = temp_project / \".foldrc\"\n    config = {\n        \"default_dialect\": \"local\",\n        \"local\": {\n            \"pre\": [\"default\"],\n            \"exclude\": [\"src/project/main.py\"],\n        },\n    }\n    with open(foldrc_path, \"w\", encoding=\"utf-8\") as f:\n        yaml.safe_dump(config, f)\n    output_file = tmp_path / \"folded.json\"\n    monkeypatch.chdir(temp_project)\n    monkeypatch.setattr(sys, \"argv\", [\"cfold\", \"fold\", \"-o\", str(output_file)])\n    main()\n    captured = capsys.readouterr()\n    assert \"Codebase folded into\" in captured.out\n    with open(output_file, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n    assert not any(f[\"path\"] == \"src/project/main.py\" for f in data[\"files\"])\n    assert any(f[\"path\"] == \"src/project/utils.py\" for f in data[\"files\"])\n    assert any(f[\"path\"] == \"docs/index.md\" for f in data[\"files\"])\n\n\ndef test_view_command(tmp_path, monkeypatch, capsys):\n    \"\"\"Test view command displays instructions and files.\"\"\"\n    fold_file = tmp_path / \"view_test.json\"\n    data = {\n        \"instructions\": [\n            {\n                \"type\": \"system\",\n                \"content\": \"System prompt\",\n                \"name\": \"sys\",\n                \"synopsis\": \"Overview\",\n            },\n            {\"type\": \"user\", \"content\": \"User prompt\"},\n        ],\n        \"files\": [\n            {\"path\": \"file1.py\", \"content\": \"code\"},\n            {\"path\": \"file2.md\", \"delete\": True},\n        ],\n    }\n    with open(fold_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f)\n\n    monkeypatch.chdir(tmp_path)\n    monkeypatch.setattr(sys, \"argv\", [\"cfold\", \"view\", str(fold_file)])\n    main()\n    captured = capsys.readouterr()\n    assert \"Instructions\" in captured.out\n    assert \"system (sys) - Overview\" in captured.out\n    assert \"user\" in captured.out\n    assert \"Files\" in captured.out\n    assert \"file1.py\" in captured.out\n    assert \"file2.md (delete)\" in captured.out\n\n\ndef test_view_invalid_file(tmp_path, monkeypatch, capsys):\n    \"\"\"Test view with invalid file shows error.\"\"\"\n    fold_file = tmp_path / \"invalid.json\"\n    fold_file.write_text(\"invalid json\")\n\n    monkeypatch.chdir(tmp_path)\n    monkeypatch.setattr(sys, \"argv\", [\"cfold\", \"view\", str(fold_file)])\n    main()\n    captured = capsys.readouterr()\n    assert \"Error loading\" in captured.out\n",
      "delete": false
    },
    {
      "path": "tests/test_utils.py",
      "content": "from cfold.utils import foldignore, instructions, treeviz\nfrom cfold.models import Codebase, FileEntry, Instruction\nfrom pydantic import ValidationError\nimport pytest\n\n\ndef test_should_include_file():\n    \"\"\"Test file inclusion/exclusion rules.\"\"\"\n    assert (\n        foldignore.should_include_file(\n            \"src/main.py\", included_patterns=[\"*.py\", \"*.md\", \"*.yml\"]\n        )\n        is True\n    )\n    assert (\n        foldignore.should_include_file(\n            \"docs/index.md\", included_patterns=[\"*.py\", \"*.md\", \"*.yml\"]\n        )\n        is True\n    )\n    assert (\n        foldignore.should_include_file(\n            \"config.yml\", included_patterns=[\"*.py\", \"*.md\", \"*.yml\"]\n        )\n        is True\n    )\n    assert (\n        foldignore.should_include_file(\n            \"build/output.o\", included_patterns=[\"*.py\", \"*.md\", \"*.yml\"]\n        )\n        is False\n    )\n    assert (\n        foldignore.should_include_file(\n            \"src/__pycache__/main.pyc\", included_patterns=[\"*.py\", \"*.md\", \"*.yml\"]\n        )\n        is False\n    )\n    assert (\n        foldignore.should_include_file(\n            \"test.txt\", included_patterns=[\"*.py\", \"*.md\", \"*.yml\"]\n        )\n        is False\n    )\n\n\ndef test_load_instructions():\n    \"\"\"Test loading instructions for a dialect.\"\"\"\n    instr, patterns = instructions.load_instructions(\"default\")\n    assert len(instr) > 0\n    assert all(isinstance(i, Instruction) for i in instr)\n    assert \"included\" in patterns\n\n\ndef test_load_instructions_invalid():\n    \"\"\"Test loading invalid dialect raises error.\"\"\"\n    with pytest.raises(ValueError):\n        instructions.load_instructions(\"invalid\")\n\n\ndef test_load_instructions_cycle():\n    \"\"\"Test cycle detection in pre dependencies.\"\"\"\n    # This would require mocking the config, but since it's file-based, skip or mock\n    pass  # For now, assume covered by implementation\n\n\ndef test_get_available_dialects():\n    \"\"\"Test getting available dialects.\"\"\"\n    dialects = instructions.get_available_dialects()\n    assert \"default\" in dialects\n    assert \"py\" in dialects\n\n\ndef test_get_folded_tree(tmp_path):\n    \"\"\"Test generating folded tree.\"\"\"\n    files = [tmp_path / \"src\" / \"main.py\", tmp_path / \"docs\" / \"index.md\"]\n    tree = treeviz.get_folded_tree(files, tmp_path)\n    assert tree.label == \"Folded files tree\"\n    assert len(tree.children) > 0\n\n\ndef test_model_validation():\n    \"\"\"Test Pydantic model validation.\"\"\"\n    # Valid FileEntry\n    FileEntry(path=\"test.py\", content=\"code\")\n    # Invalid: missing content without delete\n    with pytest.raises(ValidationError):\n        FileEntry(path=\"test.py\")\n    # Valid delete\n    FileEntry(path=\"test.py\", delete=True)\n    # Valid Codebase\n    Codebase(instructions=[Instruction(type=\"system\", content=\"test\")], files=[])\n",
      "delete": false
    }
  ]
}